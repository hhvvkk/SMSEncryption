\section{Appendix C - Encryption Protocol}

\subsection*{Introduction}

This Appendix discusses the encryption protocol designed after extensive research. It comprises of a combination of a key based encryption protocol along with a one-time pad encryption, it is because of this that I refer to the protocol as being a Hybrid encryption. This protocol is very complex and very powerful. Because it uses one time pad encryption the encryption itself is unbreakable unless you have the pad. The pad is generated using two special keys stored on each user representing the user’s internal key for that contact, and that contacts internal key for the user. Thus the pad is never communicated instead each message send contains the next key to be used. Thus it requires the previous key to get the next key creating a key dependency increasing encryption strength. However to further increase the strength the key send is used in combination with the internal key to produce the next key, because the key changes after a message has been send replay attacks are impossible as the message would no longer decrypt.

\subsection*{Diagrams}

%add die diagrams hier

\subsubsection*{Work flow diagram}

\subsection*{Description}

As stated above, the protocol is a hybrid between key based encryption and one-time pad encryption. The only way two users can communicate with each other via the SMSEncryption application is when both users have shared their keys with each other. These keys are instantiated when users add each other as "contacts" within the application. When adding a "contact", a user is provided a key that has to be shared with the intended receiver of any future messages. Once both have been provided with a key (that they share with one another; so that each of them has their own key, along with the shared key from the intended contact), both keys are stored on the device as a "contact". This is done for each contact so no keys are shared beyond one contact.
\vspace{10pt}\\
When a user wishes to send a message to a specific contact, the two keys stored for that contact is retrieved, and fed into a special function that produces a one-time pad. Before the message is encrypted, it is padded to 150 characters using spaces. Then using the one-time pad, the message is encrypted.
\vspace{10pt}\\
Once the new one-time pad has been generated, a new key is generated. This key is encoded using our special character set to represent a 10 character string. This key is then added to the end of the encrypted message bringing the total to 160 characters.
\vspace{10pt}\\
Once the key is added to the message, the initial two keys are once again fed to the special function - but this time swapped around. Yet another one-time pad is generated. This new one-time pad is then used to encrypt the original ciphertext + special key to produce the final encrypted message.
\vspace{10pt}\\
Once the message is sent, the newly produced key is used along with the internally stored key for the contact. These two keys are fed into a special key-combining function to produce a new key. The internally stored key for the contact is then replaced with the new key.
\vspace{10pt}\\
To receive a message would be the opposite: the two internally stored keys for the contact who sent the message would be retrieved, and used in the one-time pad function to produce a one-time pad. This pad is then used to decrypt the message (which will produce the original ciphertext, plus the appended special 10-digit key).
\vspace{10pt}\\
The new key is then taken from the decrypted message - as it will be the last 10 characters (the special key created by our function). The two internally stored keys are then fed into a function to produce a one-time pad, but this time the two keys are swapped. This pad is then used to decrypt the message that will produce the plaintext.
\vspace{10pt}\\
The key that was taken from the message is used in combination with the internal key for that contact to produce a new combined key, which is used to replace the key the receiver has stored for that contact.