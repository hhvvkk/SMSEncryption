\section{Appendix C - Encryption Protocol}

\subsection*{Introduction}

This Appendix discusses the encryption protocol designed after extensive research. It comprises of a combination of a key based encryption protocol along with a one-time pad encryption, it is because of this we refer to the protocol as being a Hybrid encryption. This protocol is very complex and very powerful. Because it uses one time pad encryption the encryption itself is unbreakable unless you have the pad. The pad is generated using two special keys stored on each user representing the user’s internal key for that contact, and that contacts internal key for himself. Thus the pad is never communicated instead each message send contains the next key to be used. Thus it requires the previous key to get the next key creating a key dependency, increasing encryption strength. However to further increase the strength the key send is used in combination with the internal key to produce the next key to be actually used, because the key changes after a message has been sent, replay attacks are impossible as the message would no longer decrypt.

\subsection*{Diagrams}

%add die diagrams hier

\subsubsection*{Work flow diagram}

\subsection*{Description}

As stated above, the protocol is a hybrid between key based encryption and one-time pad encryption. The only way two users can communicate with each other via the SMSEncryption application is when both users have shared their keys with each other. These keys are instantiated when users add each other as "contacts" within the application. When adding a "contact", a user is provided a key that has to be shared with the intended receiver of any future messages. Once both have been provided with a key (that they share with one another; so that each of them has their own key, along with the shared key from the intended contact), both keys are stored on the device as a "contact". This is done for each contact so no keys are shared beyond one contact.
\vspace{10pt}\\
When a user wishes to send a message to a specific contact, the two keys stored for that contact is retrieved, and fed into a special function that produces a one-time pad. Before the message is encrypted, it is padded to 144 characters using spaces.
\vspace{10pt}\\
Next a new key is generated to be used for the next communication. This key is encoded using our special character set to represent a 10 character string. This key is then added to the end of the encrypted message bringing the total to 154 characters.
\vspace{10pt}\\
Next we add the failsafe string "cos730" to the beginning of the message, this used by the application to determine the success of the decryption so that local keys are not changed on failed decryptions.
\vspace{10pt}\\
Once the key is added to the message, the message is then encrypted using the special One-Time-Pad.
\vspace{10pt}\\
Once the message is sent, the newly produced key is used along with the internally stored key for the contact. These two keys are fed into a special key-combining function to produce a new key. The internally stored key for the contact is then replaced with the new key.
\vspace{10pt}\\
To receive a message would be the opposite: the two internally stored keys for the contact that sent the message would be retrieved, and used in the one-time pad function to produce a one-time pad. This pad is then used to decrypt the message (which will produce the original plaintext, plus the appended special 10 character key, and 6 character failsafe.).
\vspace{10pt}\\
The failsafe is extracted from the message and compared to the string "cos730" to check for success. If it fails it will show error message else it would continue. The new key is then taken from the decrypted message - as it will be the last 10 characters (the special key created by our function). 
\vspace{10pt}\\
The key that was taken from the message is used in combination with the internal key for that contact to produce a new combined key, which is used to replace the key the receiver has stored for that contact.