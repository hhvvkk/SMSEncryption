\section{Appendix C - Encryption Protocol}

\subsection*{Introduction}

This Appendix discusses the encryption protocol that we designed after some extensive research. It comprises of a combination of a key-based encryption, and one-time pad encryption. Because of this combination of encryption protocols, the protocol we developed is referred to as a hybrid encryption protocol. This hybrid protocol is very complex, but very powerful. Because it uses one-time pad encryption, the ciphertext itself is unbreakable - unless you have access to the pad. The pad is generated using two special keys stored on each user’s device: one key generated locally on each device, and another key that represents the other user’s (intended receiver of messages) locally generated key (which the users have to share with one another via any means of communication). Thus, the pad used is never communicated as messages are exchanged between two parties, instead, each message sent contains the next key to be used from the pad. This creates a key dependency, as a previously sent/received key is used to determine the next key to be used. This will strengthen the encryption, as it is not possible for an attacker to know what key will be used next, even if a message is compromised somehow. However, to further increase the encryption strength, the key sent is used in combination with the local(internal) key to produce the next key to be used with future communication between these two parties. Because the key changes after a message has been sent, replay attacks are impossible as the compromised key cannot be used to read any future messages.

\subsection*{Description}

As stated above, this protocol is a hybrid between key-based encryption and one-time pad encryption. The only way two users can communicate with each other via the SMSEncryption application is when both users have shared their local keys with each other. These keys are instantiated when users add each other as "contacts" within the application. When adding a contact, a key is generated locally on the device that has to be shared with the intended receiver of any future messages. Once both users have shared their local keys with one another (so that each of them have two keys in total: their locally generated key, as well as their contact's locally generated key), both keys are stored on the device, along with other relevant data, as a contact. This is done for each contact created so that no keys are shared beyond one contact. This also limits compromised communication between two parties, as the compromised key cannot be used on messages sent between any other two parties.
\vspace{10pt}\\
Please note that messages sent with this algorithm are limited to 144 plaintext characters. The remaining 16 characters are used for synchronization purposes. Read on for more information regarding the synchronization process.
\vspace{10pt}\\
When a user wishes to send a message to a specific contact, the two keys stored for that contact are retrieved, and fed into a special function that produces a one-time pad. Before the message is encrypted, it is padded to 144 characters using spaces. This ensures a constant ciphertext length, so that any potential attackers cannot determine the plaintext message length.
\vspace{10pt}\\
Next, a new key is generated to be used for the next communication that could take place between these two users. This key is encoded using our special character set to represent a 10 character string. This key is then added to the end of the encrypted message, bringing the total amount of characters thus far to 154 characters.
\vspace{10pt}\\
Next, we add the failsafe string "cos730" to the beginning of the message. This is used by the application to determine the success of the decryption so that local keys are not changed on failed decryptions, and wrongfully used in future communcation. If the message decryption fails for some reason, resynchronization has to take place between these two users.
\vspace{10pt}\\
Once the new key is added to the message to be sent, the message is then encrypted using the special one-time pad. Local keys are also updated to maintain synchronization between the two contacts.
\vspace{10pt}\\
Once the message is sent, the newly produced key is stored as the new "locally" generated key; it is also used along with the stored key from the contact. These two keys are fed into a special key-combining function to produce yet another new key. The stored key for the contact is then replaced with this new key. Thus both keys have been updated for the specific contact.
\vspace{10pt}\\
To receive a message would be the opposite: the two internally stored keys, (one local key, and the sender of the message's (contact's) key) are retrieved, and used as parameters in the function that generates the one-time pads. This produces another one-time pad, which is then used to decrypt the received message (which will produce the original plaintext, plus the appended special 10 character key, and 6 character failsafe).
\vspace{10pt}\\
The failsafe is extracted from the message and compared to the string "cos730" to check for successful decryption. If it fails, an error message will be displayed.
\vspace{10pt}\\
If the failsafe test succeeds, the newly received key is then used in combination with the locally generated key, and fed into the special key-combining function to produce yet another new key. This key is used to replace the key stored for the contact. The received key (contained within the received message) is then stored as this user's local key. Thus, both the sender and receiver's keys have been updated.